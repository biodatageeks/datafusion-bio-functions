#!/usr/bin/env python3
"""Streaming comparison of our coverage output against samtools depth -a.

Compares per-base coverage values from our block output AND/OR per-base output
against samtools depth -a, position by position in sorted order. Streams all
files without loading into memory, so it can handle whole-genome data.

Usage:
  # Compare both per-base and block output against samtools:
  python3 compare_samtools.py <samtools_depth.tsv> --per-base <our_per_base.tsv> --blocks <our_blocks.bed>

  # Compare only block output:
  python3 compare_samtools.py <samtools_depth.tsv> --blocks <our_blocks.bed>

  # Compare only per-base output:
  python3 compare_samtools.py <samtools_depth.tsv> --per-base <our_per_base.tsv>

Input formats:
  samtools_depth.tsv: tab-separated (contig, pos_1based, coverage)
                      Generated by: samtools depth -a <bam_file>
  our_per_base.tsv:   tab-separated (contig, pos_0based, coverage)
                      Generated by: dump_coverage <bam_file> --zero-based --per-base
  our_blocks.bed:     tab-separated (contig, start_0based, end_exclusive, coverage)
                      Generated by: dump_coverage <bam_file> --zero-based
"""
import argparse
import sys


class BlockCovLookup:
    """Reads block BED file and yields coverage synchronized with sequential
    position queries. Positions not covered by any block return 0."""

    def __init__(self, path):
        self.f = open(path)
        self.cur_contig = None
        self.cur_pos = None
        self.cur_end = None
        self.cur_cov = None
        self._advance()

    def _advance(self):
        line = self.f.readline()
        if not line:
            self.cur_contig = None
            return
        parts = line.rstrip().split("\t")
        self.cur_contig = parts[0]
        self.cur_pos = int(parts[1])
        self.cur_end = int(parts[2])
        self.cur_cov = int(parts[3])

    def get_cov(self, contig, pos):
        """Get coverage at (contig, pos). Must be called in sorted order."""
        while self.cur_contig is not None:
            if self.cur_contig < contig:
                self._advance()
                continue
            if self.cur_contig == contig and self.cur_end <= pos:
                self._advance()
                continue
            break

        if (
            self.cur_contig == contig
            and self.cur_pos <= pos < self.cur_end
        ):
            return self.cur_cov
        return 0

    def close(self):
        self.f.close()


def main():
    parser = argparse.ArgumentParser(
        description="Compare our coverage output against samtools depth -a"
    )
    parser.add_argument(
        "samtools_file",
        help="samtools depth -a output (contig, pos_1based, coverage)",
    )
    parser.add_argument(
        "--per-base",
        dest="per_base_file",
        help="Our per-base output (contig, pos_0based, coverage)",
    )
    parser.add_argument(
        "--blocks",
        dest="blocks_file",
        help="Our block output in BED format (contig, start, end, coverage)",
    )
    args = parser.parse_args()

    if not args.per_base_file and not args.blocks_file:
        parser.error("At least one of --per-base or --blocks is required")

    blocks = BlockCovLookup(args.blocks_file) if args.blocks_file else None
    pb_f = open(args.per_base_file) if args.per_base_file else None

    total = 0
    pb_mismatches = 0
    blk_mismatches = 0
    first_pb_mm = []
    first_blk_mm = []

    with open(args.samtools_file) as sam_f:
        for sam_line in sam_f:
            s_parts = sam_line.rstrip().split("\t")
            s_contig = s_parts[0]
            s_pos = int(s_parts[1]) - 1  # convert 1-based to 0-based
            s_cov = int(s_parts[2])
            total += 1

            # Compare with per-base output
            if pb_f is not None:
                pb_line = pb_f.readline()
                if not pb_line:
                    print(
                        f"ERROR: per-base file ended at row {total}",
                        file=sys.stderr,
                    )
                    sys.exit(1)
                p_parts = pb_line.rstrip().split("\t")
                p_contig, p_pos, p_cov = (
                    p_parts[0],
                    int(p_parts[1]),
                    int(p_parts[2]),
                )
                if s_contig != p_contig or s_pos != p_pos:
                    print(
                        f"POSITION MISMATCH at row {total}: "
                        f"samtools=({s_contig},{s_pos}) "
                        f"per_base=({p_contig},{p_pos})"
                    )
                    sys.exit(1)
                if s_cov != p_cov:
                    pb_mismatches += 1
                    if len(first_pb_mm) < 10:
                        first_pb_mm.append(
                            f"  {s_contig}:{s_pos} samtools={s_cov} per_base={p_cov}"
                        )

            # Compare with block output
            if blocks is not None:
                b_cov = blocks.get_cov(s_contig, s_pos)
                if s_cov != b_cov:
                    blk_mismatches += 1
                    if len(first_blk_mm) < 10:
                        first_blk_mm.append(
                            f"  {s_contig}:{s_pos} samtools={s_cov} block={b_cov}"
                        )

            if total % 50_000_000 == 0:
                print(f"  ...{total:,} positions checked", file=sys.stderr)

    if pb_f is not None:
        pb_f.close()
    if blocks is not None:
        blocks.close()

    print(f"Total positions compared: {total:,}")
    if args.per_base_file:
        print(f"Per-base mismatches:     {pb_mismatches}")
    if args.blocks_file:
        print(f"Block mismatches:        {blk_mismatches}")

    if first_pb_mm:
        print("First per-base mismatches:")
        for m in first_pb_mm:
            print(m)
    if first_blk_mm:
        print("First block mismatches:")
        for m in first_blk_mm:
            print(m)
    if not first_pb_mm and not first_blk_mm:
        print("ALL VALUES MATCH")


if __name__ == "__main__":
    main()
